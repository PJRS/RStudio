---
title: "Trabajo Final R"
author: "Pavel Ramirez Samaniego"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  
    #Para utilizar con Temas de PrettyDoc
    prettydoc::html_pretty:
    theme: tactile
    highlight: vignette
    #highlight: github
    
    #Con tema basico
    #html_document:
    #toc: true
    #toc_float:
    #  collapsed: false
    #  smooth_scroll: true
    #theme: cosmo
    #highlight: haddock      
---

![](Recursos/logoEAE.png)

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

#install.packages("mapproj")
#install.packages("kableExtra")

library(knitr)
library(kableExtra)

library(mapproj)
library(plyr)
library(ggplot2)

library(shiny)
library(leaflet)
library(RColorBrewer)

```


# INTRODUCCIÓN

1. Recursos sobre expresiones regulares analizadas: Hackerearth y r-bloggers
2. Recursos sobre markdown analizadas: Rstudio y r4ds
3. Estudio descriptivo del dataset contenido en R, *_quakes_*, un dataset ya instalado en el programa

### 1. Expresiones Regulares {.tabset .tabset-pills}

<div style="text-align: justify">
Expresión regular, también conocida como regex, regexp o expresión racional, es una secuencia de caracteres que forma un patrón de búsqueda, principalmente utilizada para la búsqueda de patrones de cadenas de caracteres u operaciones de sustituciones.
A continuación, compararemos dos páginas de recursos para su aprendizaje que se pueden encontrar en Internet, destacando los pros y los contras de ambas.
</div>

### 1.1. RPubs {.tabset .tabset-pills}

 <https://www.r-bloggers.com/demystifying-regular-expressions-in-r/>
 
RPubs es el primer recurso que vamos a estudiar:
<center>Vista previa de RPubs</center>

<div style="text-align: justify">
- Contenido: Teórico y ejemplificativo. Contiene una estructura lógica, empezando por la teoría básica, para luego adentrarse en la implementación en R con sus debidos ejemplos.
- Código: Correctamente ejecutado. Se muestra el código cuando es justificado y relevante, es decir, cuando quiere mostrar como se ha llegado a aquello que trata de enseñar.
- Estética: Armoniosa y clara. Con un patrón coherente sin excesivos formatos de texto especiales.
</div>

### 1.2. Riptutorial {.tabset .tabset-pills}

 <https://www.hackerearth.com/practice/machine-learning/advanced-techniques/regular-expressions-string-manipulation-r/tutorial/>
 
Riptutorial es el segundo recurso que vamos a estudiar:
<center>Vista previa de Riptutorial</center>


<div style="text-align: justify">
- Contenido: Escaso y poco claro. Destaca las cuestiones teóricas básicas, sin poner ejemplos de ello. Para un usuario que se está iniciando con este lenguaje resulta complicado su comprendimiento y aplicación práctica.
- Código: Limitado. Más allá de enlace a otras páginas web y cambio de color sin un patrón o lógica claros, no existe un código formulado de cierta complejidad.
- Estética: Estresante. No cumple la normativa ortotipográfica ya que, tiene un color destacado y un tamaño de fuente mayor los subtítulos dentro de las secciones.
</div>

### CONCLUSIÓN:{.tabset .tabset-pills}

El nombre de la página (RIP tutorial) es un buen indicativo de la calidad instructiva del mismo. En mi opinión, llamarle tutorial es excederse. Por lo tanto, tras compararlo con los recursos que hay en RPubs, llegamos a la determinación de que este último es mejor para el aprendizaje sobre las regex. <div/>

### 2. Recursos R Markdown {.tabset .tabset-pills}

<div style="text-align: justify">
R Markdown es un formato que permite una fácil creación de documentos, presentaciones dinámicas y informes de R. Markdown es un formato de sintaxis simple para crear documentos en HTML, PDF, y Word.
A continuación, siguiendo con el mismo patrón que en el punto anterior, compararemos dos páginas de recursos para su aprendizaje que se pueden encontrar en Internet por su contenido, código y estética.
En base a dichos puntos, concluiremos cuál es mejor y cuál peor para formarse y crear buenos documentos en formato R Markdown. </div>

### 2.1. Rstudio {.tabset .tabset-pills}

Rstudio.com
<center>Vista previa de RStudio</center>

<div style="text-align: justify">
- Contenido: Conciso y claro. Indicando
- Código: Ejecución correcta.
- Estética: Coherente. Estéticamente agradable, deja claro cómo se ve en un documento Markdown el código descrito
</div>

### 2.2. R4ds {.tabset .tabset-pills}

r4ds
<center>Vista previa de r4ds</center>

- Contenido:
- Código:
- Estética:

### CONCLUSIÓN: {.tabset .tabset-pills} 
RStudio es muy buen recurso para, de un vistazo, poder saber lo básico que alcanza un documento RMarkdown.



## Sobre la base de datos

Se va a hacer un análisis del conjunto de datos de R _*quakes*_

### Detalles

Hay dos planos claros de actividad sísmica. Uno es una unión de placa principal; la otra es la trinchera de Tonga frente a Nueva Zelanda. Estos datos constituyen una submuestra de un conjunto de datos más grande que contiene 5000 observaciones.

El conjunto de datos proporciona las ubicaciones de 1000 eventos sísmicos de MB> 4.0. Los eventos ocurrieron en un cubo cerca de Fiji desde 1964

### Tabla Resumen de la base de datos (dataset):

```{r quakes, echo=FALSE}
knitr::kable(head(quakes) , align=rep('c', 5), caption = "Cabecera de datos", booktabs = T,  col.names = c("Latitud", "Longitud", "Profundidad", "Magnitud", "Estaciones")) %>%
kable_styling(latex_options = c("striped", "hold_position"), bootstrap_options = "striped", 
              full_width = T)

```

### Cantidad de datos en el dataset:

```{r cantidad de datos, echo=FALSE}
nrow(quakes)
```


# ANALISIS DE DATOS

## Entender y preparar los datos

### Entender las variables

> Latitud

La variable Latitud o **lat**, es el valor numérico	de la Latitud geografica del evento.

> Longitud

La variable Longitud o **long** es el valor numérico	de la Longitud geografica del evento.


> Profundidad

La variable Profundidad o **depth** es el valor numérico de la profundidad en kilometros.


> Magnitud

La variable Magnitud o **mag** es el valor numérico de la magnitud en la escala de Richter.

> Estaciones

La variable Estaciones o **stations** es el valor numérico de la cantidad de estaciones que informan.

## Gráficos

En este gráfico de facetas observamos por grupos la profundidad de los terremotos por su magnitud y su ubicacion.


```{r facetas, echo = FALSE}

quakes$level <- cut(quakes$depth, 5, 
  labels=c("Muy poco profundo", "Poco profundo", "Medio Profundo", "Profundo", "Muy profundo"))

quakes.summary <- ddply(quakes, .(level), summarise, mag=round(mean(mag), 1))

ggplot(quakes, aes(x=long, y=lat)) + 
  geom_point(aes(colour=mag)) + 
  geom_text(aes(label=mag), data=quakes.summary, x=185, y=-35) +
  facet_grid(~level) + 
  coord_map()+
   labs(title = "Niveles de profundidad de los evento", 
       subtitle = "5 tipos de magnitudes segun la escala de Richter",
       x = "Longitud", 
       y = "Latitud")
```




## Grafico Dinámico

<div style="text-align: justify">
Con este grafico dinamico podemos ver los puntos geograficos donde ocurrieron los terremotos o sismos de acuerdo a su intensidad y se puede acercar o alejar para tener mayor detalle de la ubicacion.


</div>



```{r shiny, echo = FALSE}

# Con Shiny

ui <- bootstrapPage(
  tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
  leafletOutput("map", width = "100%", height = "100%"),
  absolutePanel(top = 10, right = 10,
                sliderInput("range", "Magnitudes", min(quakes$mag), max(quakes$mag),
                            value = range(quakes$mag), step = 0.1
                ),
                selectInput("colors", "Esquema de Colores",
                            rownames(subset(brewer.pal.info, category %in% c("seq", "div")))
                ),
                checkboxInput("legend", "Mostrar legenda", TRUE)
  )
)

server <- function(input, output, session) {
  
  # Expresión reactiva para los datos subconjuntos a lo que el usuario seleccionó
  filteredData <- reactive({
    quakes[quakes$mag >= input$range[1] & quakes$mag <= input$range[2],]
  })
  
  # Esta expresión reactiva representa la función de paleta,
  # que cambia a medida que el usuario realiza selecciones en la Interfaz de Usuario (UI).
  colorpal <- reactive({
    colorNumeric(input$colors, quakes$mag)
  })
  
  output$map <- renderLeaflet({
    # Uso de leaflet() aqui, y solo incluye aspectos del mapa que
    # no necesitará cambiar dinámicamente (al menos, no a menos que
    # todo el mapa esté siendo derribado y recreado).
    leaflet(quakes) %>% addTiles() %>%
      fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat))
  })
  
    # Los cambios incrementales en el mapa (en este caso, reemplazando 
    # los círculos cuando se elige un nuevo color) deben realizarse en un observador.
    # Cada conjunto independiente de cosas que pueden cambiar debe gestionarse en su propio observador.
  observe({
    pal <- colorpal()
    
    leafletProxy("map", data = filteredData()) %>%
      clearShapes() %>%
      addCircles(radius = ~10^mag/10, weight = 1, color = "#777777",
                 fillColor = ~pal(mag), fillOpacity = 0.7, popup = ~paste(mag)
      )
  })
  
  # Use un observador separado para recrear la leyenda según sea necesario.
  observe({
    proxy <- leafletProxy("map", data = quakes)
    
    # Elimine cualquier leyenda existente, y solo 
    # si la leyenda está habilitada, cree una nueva.
    proxy %>% clearControls()
    if (input$legend) {
      pal <- colorpal()
      proxy %>% addLegend(position = "bottomright",
                          pal = pal, values = ~mag
      )
    }
  })
}

shinyApp(ui, server)


```


## Conclusiones

<div style="text-align: justify">
La base de datos estudiada permite ver ubicacion los lugares exactos de donde ocurrieron los terremotos con las distintas magnitudes y sirve para ver como es el recorido de las ondas segun su intensidad.
</div>